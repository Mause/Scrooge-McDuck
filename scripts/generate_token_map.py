import requests
from bs4 import BeautifulSoup
import duckdb

def get_ethereum_tokens(base_url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }
    tokens = []
    page_number = 1

    while True:
        url = f"{base_url}?p={page_number}"
        response = requests.get(url, headers=headers)
        soup = BeautifulSoup(response.content, 'html.parser')

        table = soup.find('table', {'class': 'table-hover'})

        if not table:
            break

        rows = table.find_all('tr')

        for row in rows[1:]:
            columns = row.find_all('td')
            if len(columns) > 1:
                name_tag = columns[1].find('a')
                address_tag = columns[1].find('a', href=True)

                if name_tag and address_tag:
                    full_name = name_tag.text.strip()
                    address = address_tag['href'].split('/')[-1]

                    if '\n' in full_name:
                        name, symbol = full_name.split('\n')
                        symbol = symbol.strip('()')
                    else:
                        name = full_name
                        symbol = ''

                    tokens.append((name.strip(), symbol.strip(), address.strip()))
                    print(f"Found token: {name.strip()}, {symbol.strip()}, {address.strip()}")

        page_number += 1
        next_page = soup.find('a', {'aria-label': 'Next'})
        if not next_page or 'disabled' in next_page.get('class', []):
            break

    return tokens

def generate_header(tokens, header_file):
    conn = duckdb.connect()
    conn.execute("CREATE TABLE tokens (Name VARCHAR, Symbol VARCHAR, Address VARCHAR)")
    conn.executemany("INSERT INTO tokens VALUES (?, ?, ?)", tokens)
    sorted_tokens = conn.execute("""
        FROM tokens 
        ORDER BY Symbol
    """).fetchall()

    # Open the header file for writing
    with open(header_file, 'w') as f:
        f.write('//===----------------------------------------------------------------------===//\n')
        f.write('//                         Scrooge\n')
        f.write('//\n')
        f.write('// util/eth_tokens_map.hpp\n')
        f.write('//\n')
        f.write('//===----------------------------------------------------------------------===//\n\n')
        f.write('//===----This file is auto-generated by scripts/generate_token_map.py----===//\n\n')
        f.write('#pragma once\n\n')
        f.write('#include <unordered_map>\n')
        f.write('#include <string>\n\n')
        f.write('namespace duckdb {\n')
        f.write('namespace scrooge {\n')
        f.write('const std::unordered_map<std::string, std::string> token_addresses = {\n')

        # Iterate over the sorted tokens and write each token and address
        for row in sorted_tokens:
            name, symbol, address,  = row[0], row[1], row[2]
            f.write(f'    {{"{symbol}", "{address}"}},  // {name}\n')

        f.write('};\n')

        f.write('const vector<string> token_symbols = {\n')

        for row in sorted_tokens:
            symbol = row[1]
            f.write(f'"{symbol}",\n')

        f.write('};\n')

        f.write('} // namespace scrooge\n')
        f.write('} // namespace duckdb\n')

if __name__ == "__main__":
    base_url = 'https://etherscan.io/tokens'  # Base URL for the pages with Ethereum tokens
    tokens = get_ethereum_tokens(base_url)
    header_file = 'src/include/util/eth_tokens_map.hpp'  # Output header file
    generate_header(tokens, header_file)
    print(f"Header file {header_file} generated successfully.")
